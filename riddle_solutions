#--------Challenge 0----------#
touch .hello_there

#--------Challenge 1----------#
chmod 444 .hello_there

#--------Challenge 2----------#
Ctrl+Z
fg (εντός των 10sec προτού χτυπήσει ο alarm)
//Ακόμα και αν το η διεργασία γίνει SIGSTP στον kernel συνεχίζει το countdown 
//και όταν τα 10sec παρέλθουν στέλνεται SIGALARM, το οποίο θα παραληφθεί από τη διεργασία όταν δεχθεί SIGCONT 

#--------Challenge 2 (εναλλακτική)----------#
Ctrl+Z
ps (για εύρεση PID)
kill -18 PID (-18 == -SIGCONT)

#--------Challenge 3----------#
export ANSWER='42'

#--------Challenge 4----------#
mkfifo magic_mirror

//Ένα named pipe (ή FIFO – First In First Out) είναι ένας ειδικός τύπος αρχείου στο Unix/Linux, 
που επιτρέπει επικοινωνία μεταξύ διεργασιών (Inter-Process Communication, IPC).
//Η διαφορά του από ένα “κανονικό” pipe (|) είναι ότι το named pipe έχει όνομα στο filesystem 
— δηλαδή υπάρχει ως αρχείο που μπορείς να βλέπεις και να ανοίγεις από διαφορετικά προγράμματα ή τερματικά.
//Blocking I/O. Αν δεν υπάρχει αναγνώστης ή γράφων, οι διεργασίες περιμένουν.

#--------Challenge 5----------#
aux5.c

#include <unistd.h>
#include <fcntl.h>

int main() {
        int fd = open("test", O_RDWR|O_CREAT, 0644);
        dup2(fd, 99);

        int p = fork();

        if (p == 0) {
                char *args[] = {"/home/mike/Documents/mike/OSLab/1st_Exercise_upd/riddle", NULL};
                char *env[]  = {NULL};

                execve("/home/mike/Documents/mike/OSLab/1st_Exercise_upd/riddle/riddle", args, env);
        }
        else pause();
}


#--------Challenge 5 (εναλλακτική)----------#
aux5_alt.c

#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>

int main() {
        int fd = open("test", O_RDWR|O_CREAT, 0644);
        dup2(fd, 99);
        system("./riddle");
}

#--------Challenge 6----------#
aux6.c

#include <unistd.h>
#include <stdlib.h>

int main() {
        int pipe1[2];
        int pipe2[2];

        pipe(pipe1);
        dup2(pipe1[0],33);
        dup2(pipe1[1],34);

        pipe(pipe2);
        dup2(pipe2[0],53);
        dup2(pipe2[1],54);

        system("./riddle");
}

#--------Challenge 6 (εναλλακτική)----------#
ΛΕΙΠΕΙ

#--------Challenge 7----------#
ln .hello_there .hey_there
//ln TARGET LINK_NAME

#--------Challenge 8----------#
touch bf00
truncate -s 1G bf00
echo '1' >> bf00
ln bf00 bf01
.
.
.
ln bf00 bf09

#--------Challenge 9----------#
//ανοίγω ένα τερματικό (χωρίς να τρέξω riddle) και εκτελώ την εντολή
nc -l 49842 //open server which listens to port 49842
//Ανοίγω άλλο terminal και τρέχω riddle που θα γίνει ο client.
//Καθώς τρέχω το riddle, ο κώδικας του riddle εκτελεί τις εντολές socket και connect, για να δημιουργήσει ένα end_point
//και να συνδεθεί στην port 48942 που έχει ανοίξει το πρώτο terminal

----- γενικά για επικοιν. μεταξύ terminals
//(1ο terminal) nc -l 48942
//(2o terminal) nc 127.0.0.1 48942  

#--------Challenge 10----------#
//Ουσιαστικά το πρόβλημα είναι ότι το riddle κάνει unlink το αρχείο secret_number, όπου εκεί έχει αποθηκεύσει
//τον κρυφό αριθμό. Ο reference counter μειώνεται στο μηδέν με αποτέλεσμα το αρχείο secret_number να "χάνεται".

//Προτού τρέξω riddle:
touch secret_number
ln secret_number test1
./riddle
//σε άλλο terminal για εύρεση του αριθμού
cat test1

#--------Challenge 11----------#
aux11.c

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
        int fd1 = open("secret_number", O_RDWR|O_CREAT, 0644);
        int fd2 = open("text", O_RDWR|O_CREAT, 0644);
        int p, status;

        p = fork();

        if (p == 0) {
                char *args[] = {"/home/mike/Documents/mike/OSLab/1st Exercise/riddle-20250930-0/riddle", NULL};
                char *env[]  = {NULL};

                execve("/home/mike/Documents/mike/OSLab/1st Exercise/riddle-20250930-0/riddle", args, env);
        }
        else {
                sleep(2);
                lseek(fd1,0,SEEK_SET);
                char buff[4096];
                int bytes_read = read(fd1, buff, sizeof(buff)-1);
                if (bytes_read > 0) {
                        buff[bytes_read] = '\0';  // Null-terminate
                        write(fd2, buff, bytes_read);
                }
                wait(&status);
                exit(0);
       }
}

#--------Challenge 12----------#
aux12.c

#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
        char c = '.'; //εδώ μπαίνει ο χαρακτήρας από την εκφώνηση
        int fd = open("/tmp/riddle-...", O_RDWR, 0644); //εδώ μπαίνει το αρχείο που δημιουργείται όταν τρέξω το riddle στον /tmp
        lseek(fd,111,SEEK_SET);//απεικονίζει το αρχείο με mmap() σε μία θέση μνήμη και περιμένει σε standard offset(111) να βρει τον χαρακτήρρα
        write(fd, &c, sizeof(char));
        exit(0);
}

//(1ο Βήμα) Τρέχω strace ./riddle   
//(2o Βήμα) Κάνω Ctrl+Z, για να σταματήσω εκτέλεση riddle, βρίσκω χαρακτήρα και /tmp/riddle-...
//(3o Βήμα) Ανοίγω vim aux12.c  και το ενημερώνω με τις πληροφορίες που μόλις πήρα
//(4ο Βήμα) gcc και ./aux12
//(5ο Βήμα) fg για συνέχιση riddle

#--------Challenge 13----------#
//(1ο Βήμα) chmod 644 .hello_there (δίνω δικαιώματα για -w στο .hello_there)
//(2o Βήμα) τρέχω riddle και κάνω Ctrl+Z
//(3o Βήμα) truncate -s 32768 .hello_there
//(4ο Βήμα) fg και enter στο riddle

#--------Challenge 14----------#
aux14.c

#define _GNU_SOURCE
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {

        int i;
        int status;
        while(1) {

                int p = fork();

                if (p == 0) {
                        int my_pid = getpid();
                        printf("%d\n", my_pid);
                        if (my_pid == 32767) {

                                char *args[] = {"/home/mike/Documents/mike/OSLab/1st Exercise/riddle-20250930-0/riddle", NULL};
                                char *env[]  = {NULL};
                                execve("/home/mike/Documents/mike/OSLab/1st Exercise/riddle-20250930-0/riddle", args, env);
                        }
                        else exit(0);
                }
                else if (p == 32767) break;
        }
        wait(&status);
}

#--------Challenge 15----------#
tier2.c

void setup_tier2 () {
        return;
}

//gcc -fPIC -shared tier2.c -o tier2.so
//τρέχω riddle

#--------Challenge 16----------#
aux16.c

#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>

void setup_tier2(void) {
        void *addr = (void*) 0x6042000;
        void *pid = mmap(addr, 4096, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_SHARED | MAP_FIXED | MAP_ANONYMOUS, -1, 0);
        *((long*) pid) = (long)getpid();
}

//gcc -fPIC -shared aux16.c -o tier2.so

#--------Challenge 17----------#
tier3.c

void unlock_tier3() {
        return;
}

void authorize_tier3() {
        unlock_tier3();
        return;
}

//gcc -fPIC -shared tier3.c -o tier3.so
